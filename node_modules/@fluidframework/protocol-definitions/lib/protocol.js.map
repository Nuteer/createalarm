{"version":3,"file":"protocol.js","sourceRoot":"","sources":["../src/protocol.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,MAAM,CAAN,IAAY,WA0CX;AA1CD,WAAY,WAAW;IACnB,8EAA8E;IAC9E,4BAAa,CAAA;IAEb,4EAA4E;IAC5E,kCAAmB,CAAA;IAEnB,sEAAsE;IACtE,oCAAqB,CAAA;IAErB,iCAAiC;IACjC,kCAAmB,CAAA;IAEnB,4CAA4C;IAC5C,gCAAiB,CAAA;IAEjB,aAAa;IACb,sCAAuB,CAAA;IAEvB,qBAAqB;IACrB,wCAAyB,CAAA;IAEzB,2BAA2B;IAC3B,0CAA2B,CAAA;IAE3B,qBAAqB;IACrB,+BAAgB,CAAA;IAEhB,kBAAkB;IAClB,8BAAe,CAAA;IAEf,iEAAiE;IACjE,wCAAyB,CAAA;IAEzB,0DAA0D;IAC1D,oCAAqB,CAAA;IAErB,6CAA6C;IAC7C,yCAA0B,CAAA;IAE1B,8DAA8D;IAC9D,kCAAmB,CAAA;AACvB,CAAC,EA1CW,WAAW,KAAX,WAAW,QA0CtB;AAoSD;;;;;;GAMG;AACH,MAAM,CAAN,IAAY,aAKX;AALD,WAAY,aAAa;IACrB,oDAAmC,CAAA;IACnC,wDAAuC,CAAA;IACvC,oDAAmC,CAAA;IACnC,0DAAyC,CAAA;AAC7C,CAAC,EALW,aAAa,KAAb,aAAa,QAKxB","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport enum MessageType {\n    // Empty operation message. Used to send an updated reference sequence number.\n    NoOp = \"noop\",\n\n    // System message sent to indicate a new client has joined the collaboration\n    ClientJoin = \"join\",\n\n    // System message sent to indicate a client has left the collaboration\n    ClientLeave = \"leave\",\n\n    // Proposes a new consensus value\n    Propose = \"propose\",\n\n    // Message used to reject a pending proposal\n    Reject = \"reject\",\n\n    // Summary op\n    Summarize = \"summarize\",\n\n    // Summary op written\n    SummaryAck = \"summaryAck\",\n\n    // Summary op write failure\n    SummaryNack = \"summaryNack\",\n\n    // Channel operation.\n    Operation = \"op\",\n\n    // Forced snapshot\n    Save = \"saveOp\",\n\n    // Message to indicate the need of a remote agent for a document.\n    RemoteHelp = \"remoteHelp\",\n\n    // Message to indicate that no active clients are present.\n    NoClient = \"noClient\",\n\n    // Message to indicate successful round trip.\n    RoundTrip = \"tripComplete\",\n\n    // Service specific control messages that are never sequenced.\n    Control = \"control\",\n}\n\n/**\n * Messages to track latency trace\n */\nexport interface ITrace {\n    // Service generating the trace.\n    service: string;\n\n    // Denotes receiving/sending.\n    action: string;\n\n    // Floating point time in milliseconds with up to nanosecond precision\n    timestamp: number;\n}\n\nexport interface INack {\n    // The operation that was just nacked\n    operation: IDocumentMessage | undefined;\n\n    // The sequence number the client needs to catch up to before retrying\n    sequenceNumber: number;\n\n    // Detail info about the nack.\n    content: INackContent;\n}\n\n/**\n * Document specific message\n */\nexport interface IDocumentMessage {\n    // The document's client sequence number\n    clientSequenceNumber: number;\n\n    // The reference sequence number the message was sent relative to\n    referenceSequenceNumber: number;\n\n    // The type of document message being sent\n    type: string;\n\n    // The contents of the message\n    contents: any;\n\n    // App provided metadata about the operation\n    metadata?: any;\n\n    // Server provided metadata about the operation\n    serverMetadata?: any;\n\n    // Traces related to the packet.\n    traces?: ITrace[];\n}\n\n/**\n * Document Message with optional system level data field.\n */\nexport interface IDocumentSystemMessage extends IDocumentMessage {\n\n    data: string;\n}\n\n/**\n * Branch origin information\n */\nexport interface IBranchOrigin {\n    // Origin branch of the message\n    id: string;\n\n    // Sequence number for the message in branch id\n    sequenceNumber: number;\n\n    // Min sequence number for the message in branch id\n    minimumSequenceNumber: number;\n}\n\n/**\n * Sequenced message for a distributed document\n */\nexport interface ISequencedDocumentMessage {\n    // The client ID that submitted the delta\n    clientId: string;\n\n    // The sequenced identifier\n    sequenceNumber: number;\n\n    // The term identifier\n    term: number | undefined;\n\n    // The minimum sequence number for all connected clients\n    minimumSequenceNumber: number;\n\n    // The document's client sequence number\n    clientSequenceNumber: number;\n\n    // The reference sequence number the message was sent relative to\n    referenceSequenceNumber: number;\n\n    // The type of operation\n    type: string;\n\n    // The contents of the message\n    contents: any;\n\n    // App provided metadata about the operation\n    metadata?: any;\n\n    // Server provided metadata about the operation\n    serverMetadata?: any;\n\n    // Origin branch information for the message. Can be marked undefined if the current\n    // message is also the origin.\n    origin?: IBranchOrigin;\n\n    // Traces related to the packet.\n    traces?: ITrace[];\n\n    // Timestamp when the server ticketed the message\n    timestamp: number;\n\n    /**\n     * Experimental field for storing the rolling hash at sequence number.\n     * @alpha\n     */\n    expHash1?: string;\n}\n\nexport interface ISequencedDocumentSystemMessage extends ISequencedDocumentMessage {\n    data: string;\n}\n\nexport interface ISequencedDocumentAugmentedMessage extends ISequencedDocumentMessage {\n    additionalContent: string;\n}\n\nexport interface ISignalMessage {\n\n    clientId: string | null;\n\n    content: any;\n}\n\nexport interface IUploadedSummaryDetails {\n    // Indicates whether the uploaded summary contains \".protocol\" tree\n    includesProtocolTree?: boolean;\n}\n\nexport interface ISummaryContent {\n    // Handle reference to the summary data\n    handle: string;\n\n    // Message included as part of the summary\n    message: string;\n\n    // Handles to parent summaries of the proposed new summary\n    parents: string[];\n\n    // Handle to the current latest summary stored by the service\n    head: string;\n\n    // Details of the uploaded summary\n    details?: IUploadedSummaryDetails;\n\n    // TODO - need an epoch/reload bit to indicate to clients that the summary has changed and requires a reload\n    // This could be encoded in the summary itself as well but then would require the client to download it to check\n}\n\n/**\n * General errors returned from the server.\n * May want to add error code or something similar in the future.\n */\nexport interface IServerError {\n    /**\n     * Message describing the server error.\n     */\n    errorMessage: string;\n}\n\n/**\n * Data about the original proposed summary op.\n */\nexport interface ISummaryProposal {\n    /**\n     * Actual sequence number of the summary op proposal.\n     */\n    summarySequenceNumber: number;\n}\n\n/**\n * Contents of summary ack expected from the server.\n */\nexport interface ISummaryAck {\n    /**\n     * Handle of the complete summary.\n     */\n    handle: string;\n\n    /**\n     * Information about the proposed summary op.\n     */\n    summaryProposal: ISummaryProposal;\n}\n\n/**\n * Contents of summary nack expected from the server.\n */\nexport interface ISummaryNack {\n    /**\n     * Information about the proposed summary op.\n     */\n    summaryProposal: ISummaryProposal;\n\n    /**\n     * Message describing the error.\n     * @deprecated - Use \"message\" instead. Clients should check for message ?? errorMessage.\n     * Once all servers & clients are all updated, we can remove that errorMessage property\n     */\n    errorMessage: string;\n\n    /**\n     * An error code number that represents the error. It will be a valid HTTP error code.\n     * 403 errors are non retryable.\n     * 400 errors are always immediately retriable.\n     * 429 errors are retriable or non retriable (depends on type field).\n     */\n    code?: number;\n\n    /**\n     * A message about the error for debugging/logging/telemetry purposes\n     */\n    message?: string;\n\n    /**\n     * Optional Retry-After time in seconds.\n     * If specified, the client should wait this many seconds before retrying.8\n     */\n    retryAfter?: number;\n}\n\n/**\n * Represents a message containing tasks.\n */\nexport interface IHelpMessage {\n\n    tasks: string[];\n\n    // Temporary version field for back-compat.\n    version?: string;\n}\n\n/**\n * Represents a message in task queue to be processed.\n */\nexport interface IQueueMessage {\n\n    message: IHelpMessage;\n\n    tenantId: string;\n\n    documentId: string;\n\n    token: string;\n}\n\n/**\n * Interface for nack content.\n */\nexport interface INackContent {\n    /**\n     * An error code number that represents the error. It will be a valid HTTP error code.\n     * 403 errors are non retryable and client should acquire a new identity before reconnection.\n     * 400 errors are always immediately retriable\n     * 429 errors are retriable or non retriable (depends on type field).\n     */\n    code: number;\n\n    /**\n     * Type of the Nack.\n     */\n    type: NackErrorType;\n\n    /**\n     * A message about the nack for debugging/logging/telemetry purposes\n     */\n    message: string;\n\n    /**\n     * Optional Retry-After time in seconds\n     * If specified, the client should wait this many seconds before retrying\n     */\n    retryAfter?: number;\n}\n\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nexport enum NackErrorType {\n    ThrottlingError = \"ThrottlingError\",\n    InvalidScopeError = \"InvalidScopeError\",\n    BadRequestError = \"BadRequestError\",\n    LimitExceededError = \"LimitExceededError\",\n}\n"]}