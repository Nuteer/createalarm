{"version":3,"file":"consensus.js","sourceRoot":"","sources":["../src/consensus.ts"],"names":[],"mappings":"AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IDisposable, IErrorEvent, IEventProvider } from \"@fluidframework/common-definitions\";\nimport { ISequencedClient } from \"./clients\";\n\n/**\n * Proposal to set the given key/value pair.\n *\n * Consensus on the proposal is achieved if the MSN is \\>= the sequence number\n * at which the proposal is made and no client within the collaboration window rejects\n * the proposal.\n */\nexport interface IProposal {\n    // The key for the proposal\n    key: string;\n\n    // The value of the proposal\n    value: any;\n}\n\n/**\n * Similar to IProposal except includes the sequence number when it was made in addition to the fields on IProposal\n */\nexport type ISequencedProposal = { sequenceNumber: number } & IProposal;\n\n/**\n * Adds the sequence number at which the message was approved to an ISequencedProposal\n */\nexport type IApprovedProposal = { approvalSequenceNumber: number } & ISequencedProposal;\n\n/**\n * Adds the sequence number at which the message was committed to an IApprovedProposal\n */\nexport type ICommittedProposal = { commitSequenceNumber: number } & IApprovedProposal;\n\n/**\n * A proposal that has been propposed, but not yet accepted or committed\n */\nexport interface IPendingProposal extends ISequencedProposal {\n    /**\n     * Sends a rejection for the proposal\n     */\n    reject();\n\n    /**\n     * Disables the sending of rejections for this proposal\n     */\n    disableRejection();\n\n    /**\n     * Returns true if rejections has been disable, otherwise false\n     */\n    readonly rejectionDisabled: boolean;\n}\n\n/**\n * Events fired by a Quorum in response to client tracking.\n */\nexport interface IQuorumClientsEvents extends IErrorEvent {\n    (event: \"addMember\", listener: (clientId: string, details: ISequencedClient) => void);\n    (event: \"removeMember\", listener: (clientId: string) => void);\n}\n\n/**\n * Events fired by a Quorum in response to proposal tracking.\n */\nexport interface IQuorumProposalsEvents extends IErrorEvent {\n    (event: \"addProposal\", listener: (proposal: IPendingProposal) => void);\n    (\n        event: \"approveProposal\",\n        listener: (sequenceNumber: number, key: string, value: any, approvalSequenceNumber: number) => void);\n    (\n        event: \"commitProposal\",\n        listener: (\n            sequenceNumber: number,\n            key: string,\n            value: any,\n            approvalSequenceNumber: number,\n            commitSequenceNumber: number) => void);\n    (\n        event: \"rejectProposal\",\n        listener: (sequenceNumber: number, key: string, value: any, rejections: string[]) => void);\n}\n\n/**\n * All events fired by an IQuorum, both client tracking and proposal tracking.\n */\nexport type IQuorumEvents = IQuorumClientsEvents & IQuorumProposalsEvents;\n\n/**\n * Interface for tracking clients in the Quorum.\n */\nexport interface IQuorumClients extends IEventProvider<IQuorumClientsEvents>, IDisposable {\n    getMembers(): Map<string, ISequencedClient>;\n\n    getMember(clientId: string): ISequencedClient | undefined;\n}\n\n/**\n * Interface for tracking proposals in the Quorum.\n */\nexport interface IQuorumProposals extends IEventProvider<IQuorumProposalsEvents>, IDisposable {\n    propose(key: string, value: any): Promise<void>;\n\n    has(key: string): boolean;\n\n    get(key: string): any;\n\n    getApprovalData(key: string): ICommittedProposal | undefined;\n}\n\n/**\n * Interface combining tracking of clients as well as proposals in the Quorum.\n */\nexport interface IQuorum extends\n    Omit<IQuorumClients, \"on\" | \"once\" | \"off\">,\n    Omit<IQuorumProposals, \"on\" | \"once\" | \"off\">,\n    IEventProvider<IQuorumEvents> { }\n\nexport interface IProtocolState {\n    sequenceNumber: number;\n    minimumSequenceNumber: number;\n    members: [string, ISequencedClient][];\n    proposals: [number, ISequencedProposal, string[]][];\n    values: [string, ICommittedProposal][];\n}\n\nexport interface IProcessMessageResult {\n    immediateNoOp?: boolean;\n}\n"]}