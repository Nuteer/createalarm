/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
export declare enum MessageType {
    NoOp = "noop",
    ClientJoin = "join",
    ClientLeave = "leave",
    Propose = "propose",
    Reject = "reject",
    Summarize = "summarize",
    SummaryAck = "summaryAck",
    SummaryNack = "summaryNack",
    Operation = "op",
    Save = "saveOp",
    RemoteHelp = "remoteHelp",
    NoClient = "noClient",
    RoundTrip = "tripComplete",
    Control = "control"
}
/**
 * Messages to track latency trace
 */
export interface ITrace {
    service: string;
    action: string;
    timestamp: number;
}
export interface INack {
    operation: IDocumentMessage | undefined;
    sequenceNumber: number;
    content: INackContent;
}
/**
 * Document specific message
 */
export interface IDocumentMessage {
    clientSequenceNumber: number;
    referenceSequenceNumber: number;
    type: string;
    contents: any;
    metadata?: any;
    serverMetadata?: any;
    traces?: ITrace[];
}
/**
 * Document Message with optional system level data field.
 */
export interface IDocumentSystemMessage extends IDocumentMessage {
    data: string;
}
/**
 * Branch origin information
 */
export interface IBranchOrigin {
    id: string;
    sequenceNumber: number;
    minimumSequenceNumber: number;
}
/**
 * Sequenced message for a distributed document
 */
export interface ISequencedDocumentMessage {
    clientId: string;
    sequenceNumber: number;
    term: number | undefined;
    minimumSequenceNumber: number;
    clientSequenceNumber: number;
    referenceSequenceNumber: number;
    type: string;
    contents: any;
    metadata?: any;
    serverMetadata?: any;
    origin?: IBranchOrigin;
    traces?: ITrace[];
    timestamp: number;
    /**
     * Experimental field for storing the rolling hash at sequence number.
     * @alpha
     */
    expHash1?: string;
}
export interface ISequencedDocumentSystemMessage extends ISequencedDocumentMessage {
    data: string;
}
export interface ISequencedDocumentAugmentedMessage extends ISequencedDocumentMessage {
    additionalContent: string;
}
export interface ISignalMessage {
    clientId: string | null;
    content: any;
}
export interface IUploadedSummaryDetails {
    includesProtocolTree?: boolean;
}
export interface ISummaryContent {
    handle: string;
    message: string;
    parents: string[];
    head: string;
    details?: IUploadedSummaryDetails;
}
/**
 * General errors returned from the server.
 * May want to add error code or something similar in the future.
 */
export interface IServerError {
    /**
     * Message describing the server error.
     */
    errorMessage: string;
}
/**
 * Data about the original proposed summary op.
 */
export interface ISummaryProposal {
    /**
     * Actual sequence number of the summary op proposal.
     */
    summarySequenceNumber: number;
}
/**
 * Contents of summary ack expected from the server.
 */
export interface ISummaryAck {
    /**
     * Handle of the complete summary.
     */
    handle: string;
    /**
     * Information about the proposed summary op.
     */
    summaryProposal: ISummaryProposal;
}
/**
 * Contents of summary nack expected from the server.
 */
export interface ISummaryNack {
    /**
     * Information about the proposed summary op.
     */
    summaryProposal: ISummaryProposal;
    /**
     * Message describing the error.
     * @deprecated - Use "message" instead. Clients should check for message ?? errorMessage.
     * Once all servers & clients are all updated, we can remove that errorMessage property
     */
    errorMessage: string;
    /**
     * An error code number that represents the error. It will be a valid HTTP error code.
     * 403 errors are non retryable.
     * 400 errors are always immediately retriable.
     * 429 errors are retriable or non retriable (depends on type field).
     */
    code?: number;
    /**
     * A message about the error for debugging/logging/telemetry purposes
     */
    message?: string;
    /**
     * Optional Retry-After time in seconds.
     * If specified, the client should wait this many seconds before retrying.8
     */
    retryAfter?: number;
}
/**
 * Represents a message containing tasks.
 */
export interface IHelpMessage {
    tasks: string[];
    version?: string;
}
/**
 * Represents a message in task queue to be processed.
 */
export interface IQueueMessage {
    message: IHelpMessage;
    tenantId: string;
    documentId: string;
    token: string;
}
/**
 * Interface for nack content.
 */
export interface INackContent {
    /**
     * An error code number that represents the error. It will be a valid HTTP error code.
     * 403 errors are non retryable and client should acquire a new identity before reconnection.
     * 400 errors are always immediately retriable
     * 429 errors are retriable or non retriable (depends on type field).
     */
    code: number;
    /**
     * Type of the Nack.
     */
    type: NackErrorType;
    /**
     * A message about the nack for debugging/logging/telemetry purposes
     */
    message: string;
    /**
     * Optional Retry-After time in seconds
     * If specified, the client should wait this many seconds before retrying
     */
    retryAfter?: number;
}
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
export declare enum NackErrorType {
    ThrottlingError = "ThrottlingError",
    InvalidScopeError = "InvalidScopeError",
    BadRequestError = "BadRequestError",
    LimitExceededError = "LimitExceededError"
}
//# sourceMappingURL=protocol.d.ts.map