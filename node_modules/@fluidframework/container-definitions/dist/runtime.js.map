{"version":3,"file":"runtime.js","sourceRoot":"","sources":["../src/runtime.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AA6BH;;;GAGG;AACH,IAAY,WAiBX;AAjBD,WAAY,WAAW;IACnB;;;OAGG;IACH,oCAAqB,CAAA;IAErB;;OAEG;IACH,sCAAuB,CAAA;IAEvB;;;OAGG;IACH,oCAAqB,CAAA;AACzB,CAAC,EAjBW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAiBtB;AAED,2CAA2C;AAC3C,IAAY,SAIX;AAJD,WAAY,SAAS;IACjB,kCAAqB,CAAA;IACrB,gCAAmB,CAAA;IACnB,4BAAe,CAAA;AACnB,CAAC,EAJW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAIpB;AA4HY,QAAA,eAAe,GAAiC,iBAAiB,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ITelemetryBaseLogger, IDisposable } from \"@fluidframework/common-definitions\";\nimport {\n    FluidObject,\n    IFluidCodeDetails,\n    IFluidConfiguration,\n    IFluidObject,\n    IRequest,\n    IResponse,\n} from \"@fluidframework/core-interfaces\";\nimport { IDocumentStorageService } from \"@fluidframework/driver-definitions\";\nimport {\n    IClientConfiguration,\n    IClientDetails,\n    IQuorum,\n    ISequencedDocumentMessage,\n    ISnapshotTree,\n    ITree,\n    MessageType,\n    ISummaryTree,\n    IVersion,\n    IDocumentMessage,\n} from \"@fluidframework/protocol-definitions\";\nimport { IAudience } from \"./audience\";\nimport { IDeltaManager } from \"./deltas\";\nimport { ICriticalContainerError, ContainerWarning } from \"./error\";\nimport { ILoader, ILoaderOptions } from \"./loader\";\n\n/**\n * The attachment state of some Fluid data (e.g. a container or data store), denoting whether it is uploaded to the\n * service.  The transition from detached to attached state is a one-way transition.\n */\nexport enum AttachState {\n    /**\n     * In detached state, the data is only present on the local client's machine.  It has not yet been uploaded\n     * to the service.\n     */\n    Detached = \"Detached\",\n\n    /**\n     * In attaching state, the data has started the upload to the service, but has not yet completed.\n     */\n    Attaching = \"Attaching\",\n\n    /**\n     * In attached state, the data has completed upload to the service.  It can be accessed by other clients after\n     * reaching attached state.\n     */\n    Attached = \"Attached\",\n}\n\n// Represents the bind state of the entity.\nexport enum BindState {\n    NotBound = \"NotBound\",\n    Binding = \"Binding\",\n    Bound = \"Bound\",\n}\n\n/**\n * The IRuntime represents an instantiation of a code package within a Container.\n * Primarily held by the ContainerContext to be able to interact with the running instance of the Container.\n */\nexport interface IRuntime extends IDisposable {\n\n    /**\n     * Executes a request against the runtime\n     */\n    request(request: IRequest): Promise<IResponse>;\n\n    /**\n     * Snapshots the runtime\n     */\n    snapshot(tagMessage: string, fullTree?: boolean): Promise<ITree | null>;\n\n    /**\n     * Notifies the runtime of a change in the connection state\n     */\n    setConnectionState(connected: boolean, clientId?: string);\n\n    /**\n     * Processes the given op (message)\n     */\n    process(message: ISequencedDocumentMessage, local: boolean, context: any);\n\n    /**\n     * Processes the given signal\n     */\n    processSignal(message: any, local: boolean);\n\n    /**\n     * Create a summary. Used when attaching or serializing a detached container.\n     *\n     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported\n     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the\n     * new storage IDs so requests can be redirected.\n     */\n    createSummary(blobRedirectTable?: Map<string, string>): ISummaryTree;\n\n    /**\n     * Propagate the container state when container is attaching or attached.\n     * @param attachState - State of the container.\n     */\n    setAttachState(attachState: AttachState.Attaching | AttachState.Attached): void;\n\n    /**\n     * Get pending local state in a serializable format to be given back to a newly loaded container\n     */\n    getPendingLocalState(): unknown;\n}\n\n/**\n * The ContainerContext is a proxy standing between the Container and the Container's IRuntime.\n * This allows the Container to terminate the connection to the IRuntime.\n *\n * Specifically, there is an event on Container, onContextChanged, which mean a new code proposal has been loaded,\n * so the old IRuntime is no longer valid, as its ContainerContext has been revoked,\n * and the Container has created a new ContainerContext.\n */\nexport interface IContainerContext extends IDisposable {\n    readonly id: string;\n    readonly existing: boolean | undefined;\n    readonly options: ILoaderOptions;\n    readonly configuration: IFluidConfiguration;\n    readonly clientId: string | undefined;\n    readonly clientDetails: IClientDetails;\n    readonly storage: IDocumentStorageService;\n    readonly connected: boolean;\n    readonly baseSnapshot: ISnapshotTree | undefined;\n    readonly submitFn: (type: MessageType, contents: any, batch: boolean, appData?: any) => number;\n    readonly submitSignalFn: (contents: any) => void;\n    readonly closeFn: (error?: ICriticalContainerError) => void;\n    readonly deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;\n    readonly quorum: IQuorum;\n    /**\n     * @deprecated This method is provided as a migration tool for customers currently reading the code details\n     * from within the Container by directly accessing the Quorum proposals.  The code details should not be accessed\n     * from within the Container as this requires coupling between the container contents and the code loader.\n     * Direct access to Quorum proposals will be removed in an upcoming release, and in a further future release this\n     * migration tool will be removed.\n     */\n    getSpecifiedCodeDetails?(): IFluidCodeDetails | undefined;\n    readonly audience: IAudience | undefined;\n    readonly loader: ILoader;\n    /** @deprecated - Use `taggedLogger` if present. Otherwise, be sure to handle tagged data\n     * before sending events to this logger. In time we will assume the presence of `taggedLogger`,\n     * but in the meantime, current and older loader versions buttress loggers that do not support tags.\n     * IContainerContext will retain both options, but hosts must now support tags as the loader\n     * will soon plumb taggedLogger's events (potentially tagged) to the host's logger.\n     */\n    readonly logger: ITelemetryBaseLogger;\n    // The logger implementation, which would support tagged events, should be provided by the loader.\n    readonly taggedLogger?: ITelemetryBaseLogger;\n    readonly serviceConfiguration: IClientConfiguration | undefined;\n    pendingLocalState?: unknown;\n\n    /**\n     * Ambient services provided with the context\n     */\n    readonly scope: IFluidObject & FluidObject;\n\n    raiseContainerWarning(warning: ContainerWarning): void;\n\n    /**\n     * Get an absolute url for a provided container-relative request.\n     * @param relativeUrl - A relative request within the container\n     *\n     * TODO: Optional for backwards compatibility. Make non-optional in version 0.19\n     */\n    getAbsoluteUrl?(relativeUrl: string): Promise<string | undefined>;\n\n    /**\n     * Indicates the attachment state of the container to a host service.\n     */\n    readonly attachState: AttachState;\n\n    getLoadedFromVersion(): IVersion | undefined;\n\n    updateDirtyContainerState(dirty: boolean): void;\n}\n\nexport const IRuntimeFactory: keyof IProvideRuntimeFactory = \"IRuntimeFactory\";\n\nexport interface IProvideRuntimeFactory {\n    readonly IRuntimeFactory: IRuntimeFactory;\n}\n\n/**\n * Exported module definition\n *\n * Provides the entry point for the ContainerContext to load the proper IRuntime\n * to start up the running instance of the Container.\n */\nexport interface IRuntimeFactory extends IProvideRuntimeFactory {\n    /**\n     * Instantiates a new IRuntime for the given IContainerContext to proxy to\n     * This is the main entry point to the Container's business logic\n     *\n     * @param context - container context to be supplied to the runtime\n     * @param existing - whether to instantiate for the first time or from an existing context\n     */\n    instantiateRuntime(context: IContainerContext, existing?: boolean): Promise<IRuntime>;\n}\n"]}