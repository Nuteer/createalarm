{"version":3,"file":"loader.js","sourceRoot":"","sources":["../src/loader.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAgYH;;GAEG;AACH,IAAY,YAsBX;AAtBD,WAAY,YAAY;IACpB;;OAEG;IACH,qCAAqB,CAAA;IAErB,sDAAsC,CAAA;IAEtC;;OAEG;IACH,qCAAqB,CAAA;IACrB,6CAA6B,CAAA;IAC7B,wDAAwC,CAAA;IAExC;;;;;OAKG;IACH,mCAAmB,CAAA;AACvB,CAAC,EAtBW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAsBvB","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    IRequest,\n    IResponse,\n    IFluidRouter,\n    IFluidCodeDetails,\n    IFluidPackage,\n    IProvideFluidCodeDetailsComparer,\n} from \"@fluidframework/core-interfaces\";\nimport {\n    IClientDetails,\n    IDocumentMessage,\n    IPendingProposal,\n    IQuorum,\n    ISequencedDocumentMessage,\n} from \"@fluidframework/protocol-definitions\";\nimport { IResolvedUrl } from \"@fluidframework/driver-definitions\";\nimport { IEvent, IEventProvider } from \"@fluidframework/common-definitions\";\nimport { IAudience } from \"./audience\";\nimport { IDeltaManager, ReadOnlyInfo } from \"./deltas\";\nimport { ICriticalContainerError, ContainerWarning } from \"./error\";\nimport { IFluidModule } from \"./fluidModule\";\nimport { AttachState } from \"./runtime\";\n\n/**\n * Code loading interface\n *\n * @deprecated in favor of {@link @fluidframework/container-loader#ICodeDetailsLoader}\n */\nexport interface ICodeLoader extends Partial<IProvideFluidCodeDetailsComparer> {\n    /**\n     * Loads the package specified by code details and returns a promise to its entry point exports.\n     */\n    load(source: IFluidCodeDetails): Promise<IFluidModule>;\n}\n\n/**\n * Encapsulates a module entry point with corresponding code details.\n */\nexport interface IFluidModuleWithDetails {\n    /** Fluid code module that implements the runtime factory needed to instantiate the container runtime. */\n    module: IFluidModule;\n    /**\n     * Code details associated with the module. Represents a document schema this module supports.\n     * If the code loader implements the {@link @fluidframework/core-interfaces#IFluidCodeDetailsComparer} interface,\n     * it'll be called to determine whether the module code details satisfy the new code proposal in the quorum.\n     */\n    details: IFluidCodeDetails;\n}\n\n/**\n * Fluid code loader resolves a code module matching the document schema, i.e. code details, such as\n * a package name and package version range.\n */\nexport interface ICodeDetailsLoader\n extends Partial<IProvideFluidCodeDetailsComparer> {\n /**\n  * Load the code module (package) that is capable to interact with the document.\n  *\n  * @param source - Code proposal that articulates the current schema the document is written in.\n  * @returns - Code module entry point along with the code details associated with it.\n  */\n load(source: IFluidCodeDetails): Promise<IFluidModuleWithDetails>;\n}\n\n/**\n* The interface returned from a IFluidCodeResolver which represents IFluidCodeDetails\n * that have been resolved and are ready to load\n */\nexport interface IResolvedFluidCodeDetails extends IFluidCodeDetails {\n    /**\n     * A resolved version of the Fluid package. All Fluid browser file entries should be absolute urls.\n     */\n    readonly resolvedPackage: Readonly<IFluidPackage>;\n    /**\n     * If not undefined, this id will be used to cache the entry point for the code package\n     */\n    readonly resolvedPackageCacheId: string | undefined;\n}\n\n/**\n * Fluid code resolvers take a Fluid code details, and resolve the\n * full Fluid package including absolute urls for the browser file entries.\n * The Fluid code resolver is coupled to a specific cdn and knows how to resolve\n * the code detail for loading from that cdn. This include resolving to the most recent\n * version of package that supports the provided code details.\n */\nexport interface IFluidCodeResolver {\n    /**\n     * Resolves a Fluid code details into a form that can be loaded\n     * @param details - The Fluid code details to resolve\n     * @returns - A IResolvedFluidCodeDetails where the\n     *            resolvedPackage's Fluid file entries are absolute urls, and\n     *            an optional resolvedPackageCacheId if the loaded package should be\n     *            cached.\n     */\n    resolveCodeDetails(details: IFluidCodeDetails): Promise<IResolvedFluidCodeDetails>;\n}\n\n/**\n * Code AllowListing Interface\n */\nexport interface ICodeAllowList {\n    testSource(source: IResolvedFluidCodeDetails): Promise<boolean>;\n}\n\n/**\n * Events emitted by the Container \"upwards\" to the Loader and Host\n */\nexport interface IContainerEvents extends IEvent {\n    (event: \"readonly\", listener: (readonly: boolean) => void): void;\n    (event: \"connected\", listener: (clientId: string) => void);\n    (event: \"codeDetailsProposed\", listener: (codeDetails: IFluidCodeDetails, proposal: IPendingProposal) => void);\n    (event: \"contextChanged\", listener: (codeDetails: IFluidCodeDetails) => void);\n    (event: \"disconnected\" | \"attached\", listener: () => void);\n    (event: \"closed\", listener: (error?: ICriticalContainerError) => void);\n    (event: \"warning\", listener: (error: ContainerWarning) => void);\n    (event: \"op\", listener: (message: ISequencedDocumentMessage) => void);\n    (event: \"dirty\" | \"saved\", listener: (dirty: boolean) => void);\n}\n\n/**\n * Namespace for the different connection states a container can be in\n */\nexport namespace ConnectionState {\n    /**\n     * The document is no longer connected to the delta server\n     */\n    export type Disconnected = 0;\n\n    /**\n     * The document has an inbound connection but is still pending for outbound deltas\n     */\n    export type Connecting = 1;\n\n    /**\n     * The document is fully connected\n     */\n     export type Connected = 2;\n}\n\n/**\n * Type defining the different states of connectivity a container can be in\n */\nexport type ConnectionState = ConnectionState.Disconnected | ConnectionState.Connecting | ConnectionState.Connected;\n\n/**\n * The Host's view of the Container and its connection to storage\n */\nexport interface IContainer extends IEventProvider<IContainerEvents>, IFluidRouter {\n\n    /**\n     * The Delta Manager supporting the op stream for this Container\n     */\n    deltaManager: IDeltaManager<ISequencedDocumentMessage, IDocumentMessage>;\n\n    /**\n     * The collection of write clients which were connected as of the current sequence number.\n     * Also contains a map of key-value pairs that must be agreed upon by all clients before being accepted.\n     */\n    getQuorum(): IQuorum;\n\n    /**\n     * Represents the resolved url to the Container\n     */\n    resolvedUrl: IResolvedUrl | undefined;\n\n    /**\n     * Indicates the attachment state of the container to a host service.\n     */\n    readonly attachState: AttachState;\n\n    /**\n     * The current code details for the container's runtime\n     * @deprecated use getSpecifiedCodeDetails for the code details currently specified for this container, or\n     * getLoadedCodeDetails for the code details that the container's context was loaded with.\n     * To be removed after getSpecifiedCodeDetails and getLoadedCodeDetails become ubiquitous.\n     * This is now marked as optional and due to be removed in next release.\n     */\n    readonly codeDetails?: IFluidCodeDetails | undefined;\n\n    /**\n     * Get the code details that are currently specified for the container.\n     * @returns The current code details if any are specified, undefined if none are specified.\n     */\n    getSpecifiedCodeDetails?(): IFluidCodeDetails | undefined;\n\n    /**\n     * Get the code details that were used to load the container.\n     * @returns The code details that were used to load the container if it is loaded, undefined if it is not yet\n     * loaded.\n     */\n    getLoadedCodeDetails?(): IFluidCodeDetails | undefined;\n\n    /**\n     * Returns true if the container has been closed, otherwise false\n     */\n    readonly closed: boolean;\n\n    /**\n     * Returns true if the container is dirty, i.e. there are user changes that has not been saved\n     * Closing container in this state results in data loss for user.\n     * Container usually gets into this situation due to loss of connectivity.\n     */\n    readonly isDirty: boolean;\n\n    /**\n     * Closes the container\n     */\n    close(error?: ICriticalContainerError): void;\n\n    /**\n     * Closes the container and returns serialized local state intended to be\n     * given to a newly loaded container\n     */\n    closeAndGetPendingLocalState(): string;\n\n    /**\n     * Propose new code details that define the code to be loaded\n     * for this container's runtime. The returned promise will\n     * be true when the proposal is accepted, and false if\n     * the proposal is rejected.\n     */\n    proposeCodeDetails(codeDetails: IFluidCodeDetails): Promise<boolean>\n\n    /**\n     * Attaches the Container to the Container specified by the given Request.\n     *\n     * TODO - in the case of failure options should give a retry policy. Or some continuation function\n     * that allows attachment to a secondary document.\n     */\n    attach(request: IRequest): Promise<void>;\n\n    /**\n     * Extract the snapshot from the detached container.\n     */\n    serialize(): string;\n\n    /**\n     * Get an absolute url for a provided container-relative request url.\n     * If the container is not attached, this will return undefined.\n     *\n     * @param relativeUrl - A container-relative request URL\n     */\n    getAbsoluteUrl(relativeUrl: string): Promise<string | undefined>;\n\n    /**\n     * Issue a request against the container for a resource.\n     * @param request - The request to be issued against the container\n     */\n    request(request: IRequest): Promise<IResponse>;\n\n    /**\n     * Provides the current connected state of the container\n     */\n    readonly connectionState?: ConnectionState;\n\n    /**\n     * Boolean indicating whether the container is currently connected or not\n     */\n    readonly connected?: boolean;\n\n    /**\n     * Dictates whether or not the current container will automatically attempt to reconnect to the delta stream\n     * after receiving a disconnect event\n     * @param reconnect - Boolean indicating if reconnect should automatically occur\n     * @alpha\n     */\n    setAutoReconnect?(reconnect: boolean): void;\n\n    /**\n     * Have the container attempt to resume processing ops\n     * @alpha\n     */\n    resume?(): void;\n\n    /**\n     * The audience information for all clients currently associated with the document in the current session\n     */\n    readonly audience?: IAudience;\n\n    /**\n     * The server provided ID of the client.\n     * Set once this.connected is true, otherwise undefined\n     * @alpha\n     */\n    readonly clientId?: string | undefined;\n\n    /**\n     * Tells if container is in read-only mode.\n     * Data stores should listen for \"readonly\" notifications and disallow user making changes to data stores.\n     * Readonly state can be because of no storage write permission,\n     * or due to host forcing readonly mode for container.\n     *\n     * We do not differentiate here between no write access to storage vs. host disallowing changes to container -\n     * in all cases container runtime and data stores should respect readonly state and not allow local changes.\n     *\n     * It is undefined if we have not yet established websocket connection\n     * and do not know if user has write access to a file.\n     */\n    readonly readOnlyInfo?: ReadOnlyInfo;\n\n    /**\n     * Allows the host to have the container force to be in read-only mode\n     * @param readonly - Boolean that toggles if read-only policies will be enforced\n     * @alpha\n     */\n    forceReadonly?(readonly: boolean);\n}\n\n/**\n * The Runtime's view of the Loader, used for loading Containers\n */\nexport interface ILoader extends IFluidRouter, Partial<IProvideLoader> {\n    /**\n     * Resolves the resource specified by the URL + headers contained in the request object\n     * to the underlying container that will resolve the request.\n     *\n     * An analogy for this is resolve is a DNS resolve of a Fluid container. Request then executes\n     * a request against the server found from the resolve step.\n     */\n    resolve(request: IRequest, pendingLocalState?: string): Promise<IContainer>;\n}\n\n/**\n * The Host's view of the Loader, used for loading Containers\n */\nexport interface IHostLoader extends ILoader {\n    /**\n     * Creates a new container using the specified chaincode but in an unattached state. While unattached all\n     * updates will only be local until the user explicitly attaches the container to a service provider.\n     */\n    createDetachedContainer(codeDetails: IFluidCodeDetails): Promise<IContainer>;\n\n    /**\n     * Creates a new container using the specified snapshot but in an unattached state. While unattached all\n     * updates will only be local until the user explicitly attaches the container to a service provider.\n     */\n    rehydrateDetachedContainerFromSnapshot(snapshot: string): Promise<IContainer>;\n}\n\nexport type ILoaderOptions = {\n    [key in string | number]: any;\n} & {\n    /**\n     * Set caching behavior for the loader.  If true, we will load a container from cache if one\n     * with the same id/version exists or create a new container and cache it if it does not. If\n     * false, always load a new container and don't cache it. If the container has already been\n     * closed, it will not be cached.  A cache option in the LoaderHeader for an individual\n     * request will override the Loader's value.\n     * Defaults to true.\n     */\n    cache?: boolean;\n\n    /**\n     * Provide the current Loader through the scope object when creating Containers.  It is added\n     * as the `ILoader` property, and will overwrite an existing property of the same name on the\n     * scope.  Useful for when the host wants to provide the current Loader's functionality to\n     * individual Data Stores, which is typically expected when creating with a Loader.\n     * Defaults to true.\n     */\n    provideScopeLoader?: boolean;\n\n    // Below two are the options based on which we decide how often client needs to send noops in case of active\n    // connection which is not sending any op. The end result is the \"AND\" of these 2 options. So the client\n    // should hit the min time and count to send the noop.\n    /**\n     * Set min time(in ms) frequency with which noops would be sent in case of active connection which is\n     * not sending any op.\n     */\n    noopTimeFrequency?: number;\n\n    /**\n     * Set min op frequency with which noops would be sent in case of active connection which is not sending any op.\n     */\n    noopCountFrequency?: number;\n\n    /**\n     * Max time(in ms) container will wait for a leave message of a disconnected client.\n    */\n    maxClientLeaveWaitTime?: number,\n};\n\n/**\n * Accepted header keys for requests coming to the Loader\n */\nexport enum LoaderHeader {\n    /**\n     * Override the Loader's default caching behavior for this container.\n     */\n    cache = \"fluid-cache\",\n\n    clientDetails = \"fluid-client-details\",\n\n    /**\n     * Start the container in a paused, unconnected state. Defaults to false\n     */\n    loadMode = \"loadMode\",\n    reconnect = \"fluid-reconnect\",\n    sequenceNumber = \"fluid-sequence-number\",\n\n    /**\n     * One of the following:\n     * null or \"null\": use ops, no snapshots\n     * undefined: fetch latest snapshot\n     * otherwise, version sha to load snapshot\n     */\n    version = \"version\",\n}\n\nexport interface IContainerLoadMode {\n    opsBeforeReturn?:\n        /*\n         * No trailing ops are applied before container is returned.\n         * Default value.\n         */\n        | undefined\n        /*\n         * Only cached trailing ops are applied before returning container.\n         * Caching is optional and could be implemented by the driver.\n         * If driver does not implement any kind of local caching strategy, this is same as above.\n         * Driver may cache a lot of ops, so care needs to be exercised (see below).\n         */\n        | \"cached\"\n        /*\n         * All trailing ops in storage are fetched and applied before container is returned\n         * This mode might have significant impact on boot speed (depends on storage perf characteristics)\n         * Also there might be a lot of trailing ops and applying them might take time, so hosts are\n         * recommended to have some progress UX / cancellation built into loading flow when using this option.\n         */\n        | \"all\"\n    deltaConnection?:\n        /*\n         * Connection to delta stream is made only when Container.resume() call is made. Op processing\n         * is paused (when container is returned from Loader.resolve()) until Container.resume() call is made.\n         */\n        | \"none\"\n        /*\n         * Connection to delta stream is made only when Container.resume() call is made.\n         * Op fetching from storage is performed and ops are applied as they come in.\n         * This is useful option if connection to delta stream is expensive and thus it's beneficial to move it\n         * out from critical boot sequence, but it's beneficial to allow catch up to happen as fast as possible.\n         */\n        | \"delayed\"\n        /*\n         * Connection to delta stream is made right away.\n         * Ops processing is enabled and ops are flowing through the system.\n         * Default value.\n         */\n        | undefined\n}\n\n/**\n * Set of Request Headers that the Loader understands and may inspect or modify\n */\nexport interface ILoaderHeader {\n    [LoaderHeader.cache]: boolean;\n    [LoaderHeader.clientDetails]: IClientDetails;\n    [LoaderHeader.loadMode]: IContainerLoadMode;\n    [LoaderHeader.sequenceNumber]: number;\n    [LoaderHeader.reconnect]: boolean;\n    [LoaderHeader.version]: string | undefined;\n}\n\nexport interface IProvideLoader {\n    readonly ILoader: ILoader;\n}\n\ndeclare module \"@fluidframework/core-interfaces\" {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    export interface IRequestHeader extends Partial<ILoaderHeader> { }\n\n    export interface IFluidObject  {\n        /**\n         * @deprecated - use `FluidObject<ILoader>` instead\n         */\n        readonly ILoader?: ILoader;\n    }\n}\n\nexport interface IPendingLocalState {\n    url: string;\n    pendingRuntimeState: unknown;\n}\n"]}