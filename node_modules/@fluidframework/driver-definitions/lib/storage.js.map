{"version":3,"file":"storage.js","sourceRoot":"","sources":["../src/storage.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAyOH,MAAM,CAAN,IAAY,mBAUX;AAVD,WAAY,mBAAmB;IAC3B;;OAEG;IACH,uEAAS,CAAA;IAET;;OAEG;IACH,qEAAQ,CAAA;AACZ,CAAC,EAVW,mBAAmB,KAAnB,mBAAmB,QAU9B","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IDisposable, IEventProvider, IErrorEvent, ITelemetryBaseLogger } from \"@fluidframework/common-definitions\";\nimport {\n    ConnectionMode,\n    IClient,\n    IClientConfiguration,\n    ICreateBlobResponse,\n    IDocumentMessage,\n    INack,\n    ISequencedDocumentMessage,\n    ISignalClient,\n    ISignalMessage,\n    ISnapshotTree,\n    ISummaryHandle,\n    ISummaryTree,\n    ITokenClaims,\n    ITree,\n    IVersion,\n} from \"@fluidframework/protocol-definitions\";\nimport { IResolvedUrl } from \"./urlResolver\";\n\nexport interface IDeltasFetchResult {\n    /**\n     * Sequential set of messages starting from 'from' sequence number.\n     * May be partial result, i.e. not fulfill original request in full.\n     */\n    messages: ISequencedDocumentMessage[];\n\n    /**\n     * If true, storage only partially fulfilled request, but has more ops\n     * If false, the request was fulfilled. If less ops were returned then\n     * requested, then storage does not have more ops in this range.\n     */\n    partialResult: boolean;\n}\n\n/**\n * Interface to provide access to stored deltas for a shared object\n */\nexport interface IDeltaStorageService {\n    /**\n     * Retrieves all the delta operations within the inclusive sequence number range\n     * @param tenantId - Id of the tenant.\n     * @param id - document id.\n     * @param from - first op to retrieve (inclusive)\n     * @param to - first op not to retrieve (exclusive end)\n     * @param fetchReason - Reason for fetching the messages. Example, gap between seq number\n     *  of Op on wire and known seq number. It should not contain any PII. It can be logged by\n     *  spo which could help in debugging sessions if any issue occurs.\n     */\n    get(\n        tenantId: string,\n        id: string,\n        from: number, // inclusive\n        to: number, // exclusive\n        fetchReason?: string,\n    ): Promise<IDeltasFetchResult>;\n}\n\nexport type IStreamResult<T> = { done: true; } | { done: false; value: T; };\n\n/**\n * Read interface for the Queue\n */\n export interface IStream<T> {\n    read(): Promise<IStreamResult<T>>;\n}\n\n/**\n * Interface to provide access to stored deltas for a shared object\n */\nexport interface IDocumentDeltaStorageService {\n    /**\n     * Retrieves all the delta operations within the exclusive sequence number range\n     * @param from - first op to retrieve (inclusive)\n     * @param to - first op not to retrieve (exclusive end)\n     * @param abortSignal - signal that aborts operation\n     * @param cachedOnly - return only cached ops, i.e. ops available locally on client.\n     * @param fetchReason - Reason for fetching the messages. Example, gap between seq number\n     *  of Op on wire and known seq number. It should not contain any PII. It can be logged by\n     *  spo which could help in debugging sessions if any issue occurs.\n     */\n     fetchMessages(from: number,\n        to: number | undefined,\n        abortSignal?: AbortSignal,\n        cachedOnly?: boolean,\n        fetchReason?: string,\n    ): IStream<ISequencedDocumentMessage[]>;\n}\n\nexport interface IDocumentStorageServicePolicies {\n    readonly caching?: LoaderCachingPolicy;\n\n    // If this policy is provided, it tells runtime on ideal size for blobs\n    // Blobs that are smaller than that size should be aggregated into bigger blobs\n    readonly minBlobSize?: number;\n}\n\n/**\n * Interface to provide access to snapshots saved for a shared object\n */\nexport interface IDocumentStorageService extends Partial<IDisposable> {\n    repositoryUrl: string;\n\n    /**\n     * Policies implemented/instructed by driver.\n     */\n    readonly policies?: IDocumentStorageServicePolicies;\n\n    /**\n     * Returns the snapshot tree.\n     */\n    getSnapshotTree(version?: IVersion): Promise<ISnapshotTree | null>;\n\n    /**\n     * Retrieves all versions of the document starting at the specified versionId - or null if from the head\n     */\n    getVersions(versionId: string | null, count: number): Promise<IVersion[]>;\n\n    /**\n     * Writes to the object with the given ID\n     */\n    write(root: ITree, parents: string[], message: string, ref: string): Promise<IVersion>;\n\n    /**\n     * Creates a blob out of the given buffer\n     */\n    createBlob(file: ArrayBufferLike): Promise<ICreateBlobResponse>;\n\n    /**\n     * Reads the object with the given ID, returns content in arrayBufferLike\n     */\n    readBlob(id: string): Promise<ArrayBufferLike>;\n\n    /**\n     * Uploads a summary tree to storage using the given context for reference of previous summary handle.\n     * The ISummaryHandles in the uploaded tree should have paths to indicate which summary object they are\n     * referencing from the previously acked summary.\n     * Returns the uploaded summary handle.\n     */\n    uploadSummaryWithContext(summary: ISummaryTree, context: ISummaryContext): Promise<string>;\n\n    /**\n     * Retrieves the commit that matches the packfile handle. If the packfile has already been committed and the\n     * server has deleted it this call may result in a broken promise.\n     */\n    downloadSummary(handle: ISummaryHandle): Promise<ISummaryTree>;\n}\n\nexport interface IDocumentDeltaConnectionEvents extends IErrorEvent {\n    (event: \"nack\", listener: (documentId: string, message: INack[]) => void);\n    (event: \"disconnect\", listener: (reason: any) => void);\n    (event: \"op\", listener: (documentId: string, messages: ISequencedDocumentMessage[]) => void);\n    (event: \"signal\", listener: (message: ISignalMessage) => void);\n    (event: \"pong\", listener: (latency: number) => void);\n    (event: \"error\", listener: (error: any) => void);\n}\n\nexport interface IDocumentDeltaConnection extends IDisposable, IEventProvider<IDocumentDeltaConnectionEvents> {\n    /**\n     * ClientID for the connection\n     */\n    clientId: string;\n\n    /**\n     * Claims for the client\n     */\n    claims: ITokenClaims;\n\n    /**\n     * Mode of the client\n     */\n    mode: ConnectionMode;\n\n    /**\n     * Whether the connection was made to a new or existing document\n     */\n    existing: boolean;\n\n    /**\n     * Protocol version being used with the service\n     */\n    version: string;\n\n    /**\n     * Messages sent during the connection\n     */\n    initialMessages: ISequencedDocumentMessage[];\n\n    /**\n     * Signals sent during the connection\n     */\n    initialSignals: ISignalMessage[];\n\n    /**\n     * Prior clients already connected.\n     */\n    initialClients: ISignalClient[];\n\n    /**\n     * Configuration details provided by the service\n     */\n    serviceConfiguration: IClientConfiguration;\n\n    /**\n     * Last known sequence number to ordering service at the time of connection\n     * It may lap actual last sequence number (quite a bit, if container  is very active).\n     * But it's best information for client to figure out how far it is behind, at least\n     * for \"read\" connections. \"write\" connections may use own \"join\" op to similar information,\n     * that is likely to be more up-to-date.\n     */\n    checkpointSequenceNumber?: number;\n\n    /**\n     * Properties that server can send to client to tell info about node that client is connected to. For ex, for spo\n     * it could contain info like build version, environment, region etc. These properties can be logged by client\n     * to better understand server environment etc. and use it in case error occurs.\n     * Format: \"prop1:val1;prop2:val2;prop3:val3\"\n     */\n    relayServiceAgent?: string,\n\n    /**\n     * Submit a new message to the server\n     */\n    submit(messages: IDocumentMessage[]): void;\n\n    /**\n     * Submit a new signal to the server\n     */\n    submitSignal(message: any): void;\n}\n\nexport enum LoaderCachingPolicy {\n    /**\n     * The loader should not implement any prefetching or caching policy.\n     */\n    NoCaching,\n\n    /**\n     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.\n     */\n    Prefetch,\n}\n\nexport interface IDocumentServicePolicies {\n    /**\n     * Do not connect to delta stream\n     */\n    readonly storageOnly?: boolean;\n}\n\nexport interface IDocumentService {\n\n    resolvedUrl: IResolvedUrl;\n\n    /**\n     * Policies implemented/instructed by driver.\n     */\n    policies?: IDocumentServicePolicies;\n\n    /**\n     * Access to storage associated with the document...\n     */\n    connectToStorage(): Promise<IDocumentStorageService>;\n\n    /**\n     * Access to delta storage associated with the document\n     */\n    connectToDeltaStorage(): Promise<IDocumentDeltaStorageService>;\n\n    /**\n     * Subscribes to the document delta stream\n     */\n    connectToDeltaStream(client: IClient): Promise<IDocumentDeltaConnection>;\n\n    /**\n     * Dispose storage. Called by storage consumer (Container) when it's done with storage (Container closed).\n     * Useful for storage to commit any pending state if any (including any local caching).\n     * Please note that it does not remove the need for caller to close all active delta connections,\n     * as storage may not be tracking such objects.\n     * @param error - tells if container (and storage) are closed due to critical error.\n     * Error might be due to disconnect between client & server knowlege about file, like file being overwritten\n     * in storage, but client having stale local cache.\n     * If driver implements any kind of local caching, such caches needs to be cleared on on critical errors.\n     */\n    dispose(error?: any): void;\n}\n\nexport interface IDocumentServiceFactory {\n    /**\n     * Name of the protocol used by factory\n     */\n    protocolName: string;\n\n    /**\n     * Returns an instance of IDocumentService\n     */\n    createDocumentService(resolvedUrl: IResolvedUrl, logger?: ITelemetryBaseLogger): Promise<IDocumentService>;\n\n    /**\n     * Creates a new document with the provided options. Returns the document service.\n     * @param createNewSummary - Summary used to create file. If undefined, an empty file will be created and a summary\n     * should be posted later, before connecting to ordering service.\n     */\n    createContainer(\n        createNewSummary: ISummaryTree | undefined,\n        createNewResolvedUrl: IResolvedUrl,\n        logger?: ITelemetryBaseLogger,\n    ): Promise<IDocumentService>;\n}\n\n/**\n * Context for uploading a summary to storage.\n * Indicates the previously acked summary.\n */\nexport interface ISummaryContext {\n    /**\n     * Parent summary proposed handle (from summary op)\n     */\n    readonly proposalHandle: string | undefined;\n\n    /**\n     * Parent summary acked handle (from summary ack)\n     */\n    readonly ackHandle: string | undefined;\n\n    readonly referenceSequenceNumber: number;\n}\n"]}