{"version":3,"file":"provider.js","sourceRoot":"","sources":["../src/provider.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * @internal\n * This utility type is meant for internal use by @see FluidObject\n * Produces a valid FluidObject key given a type and a property.\n * A valid FluidObject key is a property that exists on the incoming type\n * as well as on the type of the property itself. For example, IProvideFoo.IFoo.IFoo\n * This aligns with the FluidObject pattern expected to be used with all FluidObjects.\n * For example:\n * ```\n * interface IProvideFoo{\n *  IFoo: IFoo\n * }\n * interface IFoo extends IProvideFoo{\n *  foobar();\n * }\n * ```\n * This pattern enables discovery, and delegation in a standard way which is central\n * to FluidObject pattern\n */\n export type FluidObjectProviderKeys<T, TProp extends keyof T = keyof T> =\n    string extends TProp ? never : number extends TProp? never : // exclude indexers [key:string |number]: any\n    TProp extends keyof Exclude<T[TProp], undefined> // TProp is a property of T, and T[TProp]\n        ? TProp\n        :never;\n\n/**\n * This utility type take interface(s) that follow the FluidObject pattern, and produces\n * a new type that can be used for inspection and discovery of those interfaces.\n *\n * It is meant to be used with types that are known to implement the FluidObject pattern.\n * A common way to specify a type implements the FluidObject pattern is to expose it as a\n * FluidObject without a generic argument.\n *\n * For example, if we have an interface like below\n * ```\n * interface IProvideFoo{\n *  IFoo: IFoo\n * }\n * interface IFoo extends IProvideFoo{\n *  foobar();\n * }\n * ```\n *\n * and a function that returns a FluidObject. You would do the following\n *\n * `const maybeFoo: FluidObject<IFoo> = getFluidObject()`;\n *\n * Either IFoo or IProvideFoo are valid generic arguments. In both case\n * maybeFoo will be of type `{IFoo?: IFoo}`. If IFoo is not undefined,\n * then the FluidObject provides IFoo, and it can be used.\n *\n * You can inspect multiple types via a intersection. For example:\n * `FluidObject<IFoo & IBar>`\n *\n */\n export type FluidObject<T = unknown> = Partial<Pick<T, FluidObjectProviderKeys<T>>>;\n\n/**\n * This utility type creates a type that is the union of all keys on the generic type\n * which implement the FluidObject pattern. @see FluidObject\n *\n * For example `FluidObjectKeys<IFoo & IBar>` would result in `\"IFoo\" | \"IBar\"`\n *\n */\nexport type FluidObjectKeys<T> = keyof FluidObject<T>;\n"]}